%!TEX root = report.tex
\exercise{1D wavelet transforms}
A 1-dimensional `averaging-and-differencing' approach has been used to implement the discrete wavelet transform (DWT) using Haar wavelets.

\subsection{\texorpdfstring{1D \(J\)-scale DWT}{1D J-scale DWT}}
A 1-dimensional image can be transformed to its \emph{discrete Haar wavelet transform} representation by taking the average and difference of all pairs of neighbouring pixels.
The averages result in an approximation of the image, and the differences result in the details of the image.
The computed approximation can be transformed further to create an even coarser level of approximation, accompanying courser details.

To compute the new approximations and details, the following function has been implemented:
\matlabexternal{../decompose.m}
It is easily understood that the output variable \texttt{a} will be an array containing the averages of all neighbouring pairs, and \texttt{d} an array containing the differences divided by two, of all neighbouring pairs.

Note that we divided by 2 here, instead of dividing by \(\sqrt{2}\) as the exercise said.
We felt that this was a better decision because of the following two reasons:
\begin{itemize}
  \item It is more intuitive to store the average and half of the difference, since the finer levels of the images can then intuitively be restored by taking the average and \emph{adding} half of the difference, and taking the average and \emph{subtracting} half of the difference.

  Otherwise, we also had to take into account a factor of \(\sqrt{2}\) when doing the inverse operation, which we don't have to do now.
  \item Not using \(\sqrt{2}\) avoids rounding errors when dealing with integer images.
\end{itemize}

The \texttt{decompose} function is utilized by the \texttt{IPdwt} function, which computed the \texttt{J}-scale DWT of an input image \texttt{approximation}\footnote{The input image is called \texttt{approximation}, because it's a recursive function. In a deeper recursion, the input image is an approximation, so it's easier to understand this way.}:
\matlabexternal{../IPdwt.m}
The function has been implemented as a recursive function because of the recursive nature of the wavelet transform.

Applying this function to the example 1D image of length 4 yields a different result as in the exercise specification.
This is, of course, the result of dividing by \(2\) instead of \(\sqrt{2}\).
The benefit of this is that rational pixel values remain rational, and this causes the arithmetic to be exact.
The results for \(J=1\) and \(J=2\) are as follows:
\begin{lstlisting}[basicstyle=\ttfamily\small]
    f:
         1     4    -3     0

    DWT(f, J=1):
        2.5000   -1.5000   -1.5000   -1.5000

    DWT(f, J=2):
        0.5000    2.0000   -1.5000   -1.5000
\end{lstlisting}
\(J=1\) is `off' by a factor \(\sqrt{2}\) and \(J=2\) is `off' by a factor \(2\), which makes sense, since the DWT is applied once for each level.

\subsection{\texorpdfstring{1D inverse \(J\)-scale DWT}{1D inverse J-scale DWT}}
The approximations computed in the previous section, along with their accompanying details, can be used to go back to a finer level of approximation, and ultimately, the original image can be restored.

Doing this is straightforward.
Simply take the current approximation pixel and its accompanying detail pixel, and retrieve two pixels of the finer approximation:
One by adding the detail pixel to the approximation, and the other by subtracting the detail pixel from the approximation.

This step has been implemented in the \texttt{compose} function:
\matlabexternal{../compose.m}
The variable \texttt{approximation} is now twice as large as the previous approximation (called `\texttt{a}'), and uses the pixel information from the detail pixels (the variable `\texttt{d}') 

For retrieving the inverse \texttt{J}-scale DWT of an image \texttt{dwt\_rep}, represented in the DWT domain, the function \texttt{IPidwt} utilizes the \texttt{compose} function:
\matlabexternal{../IPidwt.m}
The crucial part is in line 21, where a part of the current representation is overwritten to contain the new approximation, so that it can be used in the deeper recursion.

The \texttt{IPidwt} function has been applied to the outcome of the \texttt{IPdwt} function.
It is expected that this would restore the original image\footnote{As long as the same value for \texttt{J} has been used.}, and this is confirmed by the result:
\begin{lstlisting}[basicstyle=\ttfamily\small]
    f:
         1     4    -3     0

    DWT(f, J=2):
        0.5000    2.0000   -1.5000   -1.5000

    IDWT(DWT(f, J=2), J=2):
         1     4    -3     0
\end{lstlisting}

The transformation, and the inverse transformation, also work for larger arrays.\footnote{Provided that their lengths are \(2^n\), \(n \in \mathbb{N}\).}
The script that demonstrates this, \texttt{one\_dim\_script.m}, is included in the \texttt{.zip}-file.

\clearpage